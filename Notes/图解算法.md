# 图解算法--读书笔记  
## 1.1.2  
![算法的五个条件](https://github.com/shanyingshine/photo/blob/master/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0img/%E5%9B%BE%E8%A7%A3%E7%AE%97%E6%B3%951.png?raw=true)  
## 1.1.3 时间复杂度O(f(n))  
&emsp;**时间复杂度** 可视为某算法在计算机中所需运行时间不会超过某一常熟倍数的f(n),也就是说某算法运行时间T(n)的时间复杂度（time complexity） 为 O(f(n))  
意思是存在两个常数c与n0，当n>= n0时，T(n)<=cf(n).f(n)又被称为运行时间的成长率。
![常见的Big-oh](https://github.com/shanyingshine/photo/blob/master/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0img/%E5%9B%BE%E8%A7%A3%E7%AE%97%E6%B3%952.png?raw=true)  
## 1.2.2 递归法  
&emsp;定义： 一个函数或子程序，是由自身所定义或调用的，就称为递归(Recursion)。递归至少要满足2个条件:一个可以反复执行的递归过程；一个可以离开递归执行过程的出口。  
&emsp;**`"尾归递归"`**就是函数或子程序的最后一条语句为递归调用，因为每次使用后，再回到前一次调用的额第一条语句，就是return语句，所以不需要在进行任何运算工作。  
阶乘（递归）：
```python
def factorical(i):
	if i==0:
		return 1
	else:
		ans = i*factorical(i-1)
	return ans
```
&emsp;**`"堆栈(Stack)"`**,就是一组相同数据类型的集合，所有的操作均在这个结构的顶端进行，具有“后进先出”(Last In First Out,LIFO)的特性。  
```python
def fib(n):
	if n==0;
		return 0
	elif n==1 or n==2:
		return 1
	else:
		return (fib(n-1)+fib(n-2))
```
## 1.2.3 贪心法
**贪心法**又称为 贪婪算法，方法是从某一起点开始，一直使用当前状态下最有利的选择，不断改进该解答，逐步逼近给定的目标，达到某一步骤不能再继续前进时，算法停止，就是尽可能快地求得更好的解。  
贪心法通常用于找出图的*最小生成树*(MST)、最短路径与哈弗曼编码等。
## 动态规划法
&emsp;**`动态规划法`**，用于研究多阶段决策过程的优化过程与求得一个问题的最佳解。  
&emsp;动态规划法的主要做法是：如果一个问题答案与子问题相关的话，就能将大问题拆解成各个小问题，其中与分治法最大不同的地方是可以让每一个子问题的答案被存储起来，以供下次求解时直接取用。这样做法不但能减少再次计算的时间，并可将这些解组合成大问题的解答，故而使用动态规划可以解决这些重复计算的问题。













































